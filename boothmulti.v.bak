module boothmulti #(
    parameter INPUT_WIDTH = 6 ,
    parameter OUTPUT_WIDTH = 12
  )(
    input clk, rst, enP,
    input [(INPUT_WIDTH-1):0] multiplicand, multiplier,
    output wire [(OUTPUT_WIDTH-1):0] product
  ); 

  // regs need to have one more bit at the end - dummy bit
  // reg_A stores the multiplicand
  // reg_S stores the two's complement of the multiplicand
  // reg_P stores the multiplier and the partial products of the multiplication

  reg [(OUTPUT_WIDTH):0] reg_A, reg_S, reg_P; 
  wire [(INPUT_WIDTH-1):0] complement2_A;
  wire [(OUTPUT_WIDTH):0] mux_input, mux_op, sum;

  assign complement2_A = ~(multiplicand) + 6'd1;

  assign mux_input = (reg_P[1]) ? reg_S : reg_A;

  assign sum = mux_input + reg_P;

  assign mux_op = (reg_P[1] ^ reg_P[0]) ? sum : reg_P;

  // register the inputs
  always @(posedge clk) begin
    if (rst) begin
      reg_A <= {multiplicand,7'd0};
      reg_S <= complement2_A;
    end
    
  end

  // register the product
  always @(posedge clk) begin
    if (rst)
      reg_P <= {6'd0,multiplier,1'b0};
    else if (enP)
      reg_P <= mux_op >>> 1'b1;
  end

  assign product = reg_P[(OUTPUT_WIDTH):1];

endmodule
